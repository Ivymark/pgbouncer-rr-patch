--- ../pgbouncer/src/client.c	2020-04-12 12:53:20.000000000 +0300
+++ ./src/client.c	2020-05-09 09:37:17.000000000 +0300
@@ -1,3 +1,4 @@
+
 /*
  * PgBouncer - Lightweight connection pooler for PostgreSQL.
  *
@@ -630,7 +631,7 @@
 {
 	SBuf *sbuf = &client->sbuf;
 	int rfq_delta = 0;
-
+	long last_tx_time = 0;
 	switch (pkt->type) {
 
 	/* one-packet queries */
@@ -695,6 +696,39 @@
 	if (client->pool->db->admin)
 		return admin_handle_client(client, pkt);
 
+	/* pgbouncer-rr extensions: query rewrite & client connection routing */
+	if(client->link && client->link->idle_tx) {
+		last_tx_time = (long)time(NULL);
+		slog_info(client, "last transaction time on this connection is %d", last_tx_time);
+		slog_info(client, "SKIPPING ROUTING RULES: client is transacting");
+		return skip_query_interception(client, pkt, rfq_delta);
+		// if (rfq_delta) {
+		// 	client->expect_rfq_count += rfq_delta;
+		// }
+
+		// client->pool->stats.client_bytes += pkt->len;
+
+		// /* tag the server as dirty */
+		// client->link->ready = false;
+		// client->link->idle_tx = false;
+
+		// /* forward the packet */
+		// sbuf_prepare_send(sbuf, &client->link->sbuf, pkt->len);
+		// return true;
+	}
+	
+	if (pkt->type == 'Q' || pkt->type == 'P') {
+		if((long)time(NULL) - last_tx_time < 300) {
+			slog_info(client, 'time since last TX is to low %d skipping routing', (long)time(NULL) - last_tx_time);
+			return skip_query_interception(client, pkt, rfq_delta);
+		}
+		slog_info(client, "Conditions for rr patch met");
+		if (!rewrite_query(client, pkt)) {
+			return false;
+		}
+        route_client_connection(client, pkt);
+	}
+
 	/* acquire server */
 	if (!find_server(client))
 		return false;
